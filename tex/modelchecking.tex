\section{Ausblick: Modelchecking}

Der folgende Abschnitt beschäftigt sich mit der theoretischen Fragestellung, ob ein gegebenes Modell eines Systems/Programms eine gegebene Spezifikation erfüllt. Die Spezifikation wird in Form einer LTL Formel angegeben, während das Programm selbst mit Hilfe eines "`finite state"' Programms modelliert wird. Die Erfüllbarkeit und Gültigkeit von LTL Formel stehen im Folgenden nicht im Vordergrund, da diese Eigenschaften beim Modelchecking eher uninteressant sind \cite{vardi+96}. Sie sollten gegeben sein, denn das Hauptziel von Modelchecking ist zu verifizieren, ob eine Formel für ein bestimmtes Modell gilt -- nicht, ob sie überhaupt gilt. 

\subsection{"`Finite State"' Programme und Verifikation}

Im Vergleich zu anderer gängiger Literatur, wo meist gelabelte Transitionssysteme verwendet werden \cite{huth+04}, werden hier im Folgenden -- analog zu \cite{vardi+96} -- nun als Programmmodelle "`finite state"' Programme betrachtet. Dabei wird ausgenutzt, dass jeder Zustand des Programms mit einer endlichen Menge von Informationen beschrieben werden kann -- diese Informationen lassen sich in Form von atomaren Aussagen ($Prop$) formulieren. Sei nun ein finite state Programm notiert als Tupel $P = (W, w_0, R, V)$, wobei $W$ die (endliche) Menge aller Zustände, $w_0$ der Startzustand und $R \subseteq W^2$ eine totale Erreichbarkeitsrelation ist. $V: W \rightarrow 2^{Prop}$ ist eine Funktion, die für jedes Element in $W$ den Elementen von $Prop$ Wahrheitswerte zuweist, wobei $Prop$ die möglichen elementaren Informationen, die Aussagen über die Zustände des Programms sind.

Nun muss der Begriff einer "`Berechnung"' eines solchen finite state Programms $P$ definiert werden. Dazu betrachten wir eine unendliche Abfolge von Zuständen $u = u_0, u_1, ... $ wobei $\forall i \geq 0: u_i \in W$ und $u_0 = w_0$. Nun werden allen Zuständen in $u$ durch die Funktion $V$ atomare Aussagen zugewiesen, sodass $\pi = V(u_0), V(u_1), ...$. Wir bezeichnen $\pi$ als \textit{eine} Berechnung des finite state Programms $P$ (streng nach \cite{vardi+96}). Wie zu erkennen ist, haben die "`Berechnung"' eines finite state Programms und die "`Berechnung"' mit deren Hilfe die Semantik von LTL Formeln hergeleitet wurde (siehe \ref{ltl:semantik}), sehr viel gemeinsam. 

Wir sagen, dass $P$ eine gegebene LTL Formel $\varphi$ erfüllt, wenn \textit{alle} Berechnungen in $P$ die Formel $\varphi$ erfüllen. Die Entscheidung, ob ein finite state Programm $P$ eine Formel $\varphi$ erfüllt wird als "`Verifikationsproblem"' bezeichnet \cite{vardi+96}. Beim Modelchecking geht es darum, die Fragestellung des Verifikationsproblems eindeutig zu beantworten \cite{huth+04,vardi+96}.

Um letztendlich das Verifikationspropblem mit automatentheoretischen Mitteln lösen zu können, muss noch eine Überführung von finite state Programmen zu Büchi-Automaten angegeben werden. Dafür sei auf \cite[kap. 4.2]{vardi+96} verwiesen. Mit dem dort beschriebenen Verfahren wird ein Büchi-Automat $A_P$ erzeugt, bei dem jeder unendliche Lauf akzeptierend ist, sodass die Sprache des Automaten $L_\omega(A_P)$ exakt die Menge aller Berechnungen von $P$ abbildet. Schlussendlich wird das Verifikationsproblem für eine Formel $\varphi$ und ein finite state Programm $P$ darauf reduziert zu überprüfen, ob alle akzeptierten Worte des Automaten $A_P$ die Formel $\varphi$ erfüllen.